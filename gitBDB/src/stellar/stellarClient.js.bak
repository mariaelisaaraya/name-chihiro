// src/stellar/stellarClient.js
// Stellar SDK + Wallets Kit integration for "Chihiro's Lost Name"
//
// Sources verificadas contra documentación oficial:
//   → developers.stellar.org/docs/build/guides/transactions/invoke-contract-tx-sdk
//   → developers.stellar.org/docs/build/guides/transactions/signing-soroban-invocations
//   → stellarwalletskit.dev (v2.0.0, released 2026-02-11)

// ─── Wallets Kit v2 ────────────────────────────────────────────────────────────
// IMPORTANTE: paquete oficial es @creit-tech (con guión, JSR).
// @creit.tech (con punto, NPM) es V1 y va a deprecarse — stellarwalletskit.dev/installation
//
// V2 API es estática: StellarWalletsKit.init() + StellarWalletsKit.createButton()
// V1 API era instanciada: new StellarWalletsKit({...}) — YA NO SE USA
import { StellarWalletsKit } from "@creit-tech/stellar-wallets-kit";
import { FreighterModule } from "@creit-tech/stellar-wallets-kit/sdk/modules/freighter.module";

// ─── Stellar SDK — subpaths oficiales ─────────────────────────────────────────
// Fuente: developers.stellar.org/docs/build/guides/transactions/signing-soroban-invocations
// "import { Server, assembleTransaction } from '@stellar/stellar-sdk/rpc'"
import { Server, assembleTransaction, isSimulationError } from "@stellar/stellar-sdk/rpc";

import {
  Contract,
  Networks,
  TransactionBuilder,
  BASE_FEE,
  xdr,
  Address,
  scValToNative,
} from "@stellar/stellar-sdk";

// ─── Network constants ────────────────────────────────────────────────────────

export const RPC_URL = "https://soroban-testnet.stellar.org";
export const NETWORK_PASSPHRASE = Networks.TESTNET;

// Game Hub — dirección fija, deployada por organizadores del hackathon
export const GAME_HUB_CONTRACT_ID =
  "CB4VZAT2U3UC6XFK3N23SKRF2NDCMP3QHJYMCHHFMZO7MRQO6DQ2EMYG";

// Seteá estas en .env después de deployar:
//   VITE_CHIHIRO_CONTRACT_ID=C...
//   VITE_ULTRAHONK_VERIFIER_ID=C...
export const CHIHIRO_CONTRACT_ID =
  import.meta.env.VITE_CHIHIRO_CONTRACT_ID ?? null;

export const ULTRAHONK_VERIFIER_ID =
  import.meta.env.VITE_ULTRAHONK_VERIFIER_ID ?? null;

// ─── Inicialización del Kit (una sola vez) ────────────────────────────────────
// V2 usa API estática — se llama init() una vez al arrancar la app.
// Fuente: stellarwalletskit.dev → "Start the kit"
let _kitInitialized = false;

function ensureKit() {
  if (!_kitInitialized) {
    console.log("[WalletKit] Initializing StellarWalletsKit (v2 static API)");
    StellarWalletsKit.init({
      modules: [new FreighterModule()],
      // Tell the kit we are on TESTNET so Freighter doesn't silently reject
      // address requests that come from a non-PUBLIC network context.
      network: Networks.TESTNET,
    });
    _kitInitialized = true;
    console.log("[WalletKit] Kit initialized — network: TESTNET");
  }
}

// ─── RPC Server singleton ─────────────────────────────────────────────────────
// Fuente: developers.stellar.org — "import { Server } from '@stellar/stellar-sdk/rpc'"
let _rpc = null;
function getRpc() {
  if (!_rpc) _rpc = new Server(RPC_URL);
  return _rpc;
}

// ─── Wallet API ───────────────────────────────────────────────────────────────

const CONNECT_TIMEOUT_MS = 15_000; // 15 s — Freighter popup won't last longer

/**
 * Muestra el modal de selección de wallet y resuelve con la dirección G...
 *
 * Fixes applied vs previous version:
 *  - openModal() in v2 returns void, not a Promise → must NOT chain .catch()
 *  - getAddress() is wrapped in a 15-second timeout so it can never hang forever
 *  - network: TESTNET passed to init() so Freighter accepts the request
 *  - console logging at every step so hangs are visible in DevTools
 */
export async function connectWallet() {
  ensureKit();

  return new Promise((resolve, reject) => {
    console.log("[WalletKit] Opening wallet selection modal…");

    // Helper: wrap any promise with a timeout so getAddress() can't hang.
    function withTimeout(promise, ms, label) {
      const timer = new Promise((_, rej) =>
        setTimeout(
          () => rej(new Error(`[WalletKit] Timeout (${ms}ms): ${label}`)),
          ms
        )
      );
      return Promise.race([promise, timer]);
    }

    // openModal() in v2 is fire-and-forget (returns void).
    // Do NOT chain .catch() on it — that throws "openModal is not a function" or
    // "Cannot read properties of undefined" when the return value is void.
    StellarWalletsKit.authModal({
      onWalletSelected: async (option) => {
        console.log("[WalletKit] Wallet selected by user:", option.id, option.name);

        try {
          console.log("[WalletKit] Calling setWallet:", option.id);
          StellarWalletsKit.setWallet(option.id);

          console.log("[WalletKit] Calling getAddress() — waiting for Freighter popup…");
          const { address } = await withTimeout(
            StellarWalletsKit.getAddress(),
            CONNECT_TIMEOUT_MS,
            "getAddress()"
          );

          if (!address) {
            throw new Error("[WalletKit] getAddress() returned empty address");
          }

          console.log("[WalletKit] ✓ Connected:", address);
          resolve(address);
        } catch (err) {
          console.error("[WalletKit] Error after wallet selection:", err);
          reject(err);
        }
      },

      onClosed: (reason) => {
        // Only reject if we haven't already resolved.
        // reason is "CLOSED" (user dismissed) or undefined.
        console.log("[WalletKit] Modal closed — reason:", reason ?? "user dismissed");
        reject(new Error("Modal cerrado sin conectar"));
      },
    });

    console.log("[WalletKit] Modal opened — waiting for user selection…");
  });
}

export async function disconnectWallet() {
  ensureKit();
  StellarWalletsKit.disconnect?.();
}

/**
 * Devuelve la dirección conectada actualmente, o null si no hay wallet.
 * Seguro de llamar en mount — swallows el error "not connected".
 */
export async function getConnectedAddress() {
  try {
    ensureKit();
    const { address } = await StellarWalletsKit.getAddress();
    return address || null;
  } catch {
    return null;
  }
}

// ─── Core invoke ──────────────────────────────────────────────────────────────
// Patrón oficial Soroban para write-calls:
//   build → prepareTransaction (simulate + assemble en 1 paso) → sign → submit → poll
//
// Fuente: developers.stellar.org/docs/build/guides/transactions/invoke-contract-tx-sdk
// "prepareTransaction simulates and assembles in one step"
//
// También: developers.stellar.org/docs/build/guides/transactions/simulateTransaction-Deep-Dive
// "you can also call prepareTransaction to have it both simulate and assemble
//  the transaction for you in one step"
//
async function invoke(contractId, method, args, signerAddress) {
  ensureKit();
  const rpc = getRpc();

  // 1. Obtener cuenta (número de secuencia actualizado)
  const account = await rpc.getAccount(signerAddress);

  // 2. Construir la transacción
  // BASE_FEE = 100 stroops. El fee real se determina en prepareTransaction.
  const tx = new TransactionBuilder(account, {
    fee: BASE_FEE,
    networkPassphrase: NETWORK_PASSPHRASE,
  })
    .addOperation(new Contract(contractId).call(method, ...args))
    .setTimeout(30)
    .build();

  // 3. prepareTransaction = simulate + assemble en un solo paso (patrón oficial)
  // Agrega el footprint, resource fees y auth entries al tx automáticamente.
  // Si hay ledger entries archivados, lanza un error con restorePreamble.
  let preparedTx;
  try {
    preparedTx = await rpc.prepareTransaction(tx);
  } catch (e) {
    throw new Error(`Prepare transaction failed: ${e.message}`);
  }

  // 4. Firmar — abre el popup del wallet (Freighter muestra los detalles al usuario)
  // V2 API: signTransaction es método estático, requiere 'address' en las options
  // Fuente: stellarwalletskit.dev — "Sign a transaction"
  const { signedTxXdr } = await StellarWalletsKit.signTransaction(
    preparedTx.toXDR(),
    {
      networkPassphrase: NETWORK_PASSPHRASE,
      address: signerAddress,
    }
  );

  // 5. Enviar
  const submitted = await rpc.sendTransaction(
    TransactionBuilder.fromXDR(signedTxXdr, NETWORK_PASSPHRASE)
  );

  if (submitted.status === "ERROR") {
    throw new Error(`Submit error: ${JSON.stringify(submitted.errorResult)}`);
  }

  // 6. Polling — flujo de estados oficial:
  //    PENDING → ledger cierra (~5s) → NOT_FOUND (propagando) → SUCCESS | FAILED
  //
  // Fuente: developers.stellar.org/docs/build/guides/transactions/invoke-contract-tx-sdk
  // (Python example): "Poll `get_transaction` until the status is not 'NOT_FOUND'"
  const txHash = submitted.hash;

  if (submitted.status === "PENDING") {
    for (let i = 0; i < 20; i++) {
      await new Promise((r) => setTimeout(r, 1000));
      const result = await rpc.getTransaction(txHash);

      if (result.status === "SUCCESS") {
        return {
          txHash,
          result: result.returnValue ? scValToNative(result.returnValue) : null,
        };
      }
      if (result.status === "FAILED") {
        throw new Error(`Transaction failed on-chain. Hash: ${txHash}`);
      }
      // NOT_FOUND = todavía propagando, seguir esperando
    }
    throw new Error(`No confirmado después de 20s. Hash: ${txHash}`);
  }

  // Raro: SUCCESS inmediato (testnet local)
  if (submitted.status === "SUCCESS") {
    return { txHash, result: null };
  }

  throw new Error(`Status inesperado: ${submitted.status}`);
}

// ─── Funciones del juego ──────────────────────────────────────────────────────

/**
 * ADMIN — Inicializa el juego (player1).
 * Llama ChihiroGame.initialize() → game_hub.start_game(player1, player2)
 *
 * nameCommitHex = Poseidon2(nameSecret, salt) computado en el browser.
 * El secreto NUNCA sale del browser — solo se guarda el hash on-chain.
 */
export async function initializeGame({
  adminAddress,
  player2Address,
  nameCommitHex,
  verificationKey = "00",  // fallback para demo sin vk real
  vkHex = null,            // si se provee, sobreescribe verificationKey
  contractId = CHIHIRO_CONTRACT_ID,
}) {
  if (!contractId) throw new Error("Setear VITE_CHIHIRO_CONTRACT_ID en .env");

  // vkHex real (de proof.json) tiene prioridad sobre verificationKey placeholder
  const vkToUse = vkHex ?? verificationKey;

  const args = [
    new Address(adminAddress).toScVal(),
    new Address(player2Address).toScVal(),
    hexToBytes32(nameCommitHex),
    new Address(GAME_HUB_CONTRACT_ID).toScVal(),
    new Address(ULTRAHONK_VERIFIER_ID ?? adminAddress).toScVal(), // fallback para demo
    hexToBytes(vkToUse),
  ];

  return invoke(contractId, "initialize", args, adminAddress);
}

/**
 * PLAYER — Recupera el nombre con una prueba ZK (player2 / Chihiro).
 * Llama ChihiroGame.recover_name() → UltraHonkVerifier.verify() → game_hub.end_game()
 *
 * ZK en Stellar: Protocol 25 "X-Ray" agregó funciones host BN254 + Poseidon.
 * Fuente: developers.stellar.org/docs/build/apps/zk
 */
export async function recoverName({
  playerAddress,
  proofHex,
  nameCommitHex,
  contractId = CHIHIRO_CONTRACT_ID,
  vkHex = null,
}) {
  if (!contractId) throw new Error("Setear VITE_CHIHIRO_CONTRACT_ID en .env");

  // public_inputs: Vec<BytesN<32>> — el único output público del circuito es nameCommit
  const publicInputsVec = xdr.ScVal.scvVec([hexToBytes32(nameCommitHex)]);

  const args = [
    new Address(playerAddress).toScVal(),
    hexToBytes(proofHex),
    publicInputsVec,
  ];

  return invoke(contractId, "recover_name", args, playerAddress);
}

/**
 * Lee el estado del juego — gratis, sin firmar.
 * Usa simulateTransaction que NUNCA envía nada a la red.
 *
 * Para simulate necesitamos una cuenta source válida para construir el tx.
 * Usamos getAccount con una cuenta conocida de testnet — solo para el número
 * de secuencia, nunca se envía nada.
 */
export async function getGameStatus(contractId = CHIHIRO_CONTRACT_ID) {
  if (!contractId) return null;
  try {
    const rpc = getRpc();

    // Cuenta pública de testnet conocida — solo para estructurar el tx de simulación
    const source = await rpc.getAccount(
      "GAAZI4TCR3TY5OJHCTJC2A4QSY6CJWJH5IAJTGKIN2ER7LBNVKOCCWN"
    );

    const tx = new TransactionBuilder(source, {
      fee: BASE_FEE,
      networkPassphrase: NETWORK_PASSPHRASE,
    })
      .addOperation(new Contract(contractId).call("get_game_status"))
      .setTimeout(30)
      .build();

    const simResult = await rpc.simulateTransaction(tx);

    if (isSimulationError(simResult) || !simResult.result?.retval) return null;

    // Contrato retorna (game_id: u64, started: bool, ended: bool)
    const native = scValToNative(simResult.result.retval);
    return { gameId: native[0], started: native[1], ended: native[2] };
  } catch {
    return null;
  }
}

// ─── Helpers de encoding ──────────────────────────────────────────────────────

/** hex string → xdr.ScVal Bytes longitud variable (para proof y vk) */
function hexToBytes(hex) {
  return xdr.ScVal.scvBytes(Buffer.from(hex.replace(/^0x/, ""), "hex"));
}

/** hex string → xdr.ScVal Bytes exactamente 32 bytes (para nameCommit: BytesN<32>) */
function hexToBytes32(hex) {
  const clean = hex.replace(/^0x/, "").padStart(64, "0").slice(0, 64);
  return xdr.ScVal.scvBytes(Buffer.from(clean, "hex"));
}

// ─── Helpers de display ───────────────────────────────────────────────────────

/** Acorta una dirección Stellar para mostrar: GABCD...XY12 */
export function formatAddress(addr) {
  if (!addr || addr.length < 12) return addr ?? "";
  return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
}

/** Link a StellarExpert para una tx de testnet */
export function explorerTxUrl(txHash) {
  return `https://stellar.expert/explorer/testnet/tx/${txHash}`;
}
